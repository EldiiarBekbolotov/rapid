name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags (e.g., v1.0.0)

  workflow_dispatch:  # Allow manual triggering

# Environment variables available to all jobs and steps in this workflow
env:
  QT_VERSION: '6.5.0'
  AQT_VERSION: '3.1.7'
  PY7ZR_VERSION: '0.20.8'

jobs:
  build:
    name: Build (${{ matrix.os }}, ${{ matrix.qt_arch }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS
          - os: macos-latest
            qt_host: 'mac'
            qt_arch: 'clang_64'
            build_script: 'scripts/build_mac.sh'
            package_script: 'scripts/package_mac.sh'
            artifact_name: 'Rapid-macOS'
            target: 'desktop'
          # Windows
          - os: windows-latest
            qt_host: 'windows'
            qt_arch: 'win64_msvc2019_64'
            build_script: 'scripts/build_windows.ps1'
            package_script: 'scripts/package_windows.ps1'
            artifact_name: 'Rapid-Windows'
            target: 'desktop'
          # Linux (WASM)
          - os: ubuntu-latest
            qt_host: 'linux'
            qt_arch: 'wasm_32'
            build_script: 'scripts/build_wasm.sh'
            package_script: ''
            artifact_name: 'Rapid-Web'
            target: 'desktop'  # WASM is considered a desktop target for Qt
            
    env:
      # WASM specific environment variables
      EMSDK_VERSION: '3.1.45'
      EMSDK: /opt/emsdk
      EMSCRIPTEN_VERSION: '3.1.45'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    # WASM-specific setup
    - name: Set up Emscripten (WASM only)
      if: matrix.qt_arch == 'wasm_32'
      shell: bash
      run: |
        echo "Setting up Emscripten..."
        set -e  # Exit immediately if any command fails
        
        # Clone and set up Emscripten if not already present
        if [ ! -d "${{ env.EMSDK }}" ]; then
          git clone https://github.com/emscripten-core/emsdk.git ${{ env.EMSDK }} || {
            echo "‚ùå Failed to clone Emscripten SDK"
            exit 1
          }
        fi
        
        cd ${{ env.EMSDK }}
        
        # Install and activate specific version
        ./emsdk install ${{ env.EMSDK_VERSION }} || {
          echo "‚ùå Failed to install Emscripten ${{ env.EMSDK_VERSION }}"
          exit 1
        }
        
        ./emsdk activate ${{ env.EMSDK_VERSION }} || {
          echo "‚ùå Failed to activate Emscripten ${{ env.EMSDK_VERSION }}"
          exit 1
        }
        
        # Source the environment to make emcc available in current shell
        source ./emsdk_env.sh
        
        # Set up environment variables for subsequent steps
        echo "${{ env.EMSDK }}/upstream/emscripten" >> $GITHUB_PATH
        echo "${{ env.EMSDK }}/upstream/bin" >> $GITHUB_PATH
        echo "EMSDK=${{ env.EMSDK }}" >> $GITHUB_ENV
        echo "EMSCRIPTEN=${{ env.EMSDK }}/upstream/emscripten" >> $GITHUB_ENV
        
        # Verify Emscripten installation
        echo "Checking Emscripten installation..."
        emcc --version || {
          echo "‚ùå Emscripten not properly installed"
          exit 1
        }
        echo "‚úÖ Emscripten installed successfully"
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install Python dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip
        python -m pip install setuptools wheel "py7zr==${{ env.PY7ZR_VERSION }}"
        python -m pip install aqtinstall==${{ env.AQT_VERSION }}
    
    - name: Install Qt
      id: install_qt
      shell: bash
      run: |
        # Install Qt
        python -m aqt install-qt ${{ matrix.qt_host }} desktop ${{ env.QT_VERSION }} ${{ matrix.qt_arch }} -m qtwebengine --autodesktop
        
        # Add Qt to PATH
        if [ "${{ runner.os }}" = "macOS" ]; then
          QT_PATH="$HOME/Qt/${{ env.QT_VERSION }}/${{ matrix.qt_arch }}"
        elif [ "${{ runner.os }}" = "Linux" ]; then
          QT_PATH="$HOME/Qt/${{ env.QT_VERSION }}/${{ matrix.qt_arch }}"
        else  # Windows
          QT_PATH="C:\\Qt\\${{ env.QT_VERSION }}\\${{ matrix.qt_arch }}"
        fi
        
        echo "Qt installation path: $QT_PATH"
        echo "$QT_PATH/bin" >> $GITHUB_PATH
        echo "QT_PATH=$QT_PATH" >> $GITHUB_ENV
    
    - name: Verify Qt Installation
      shell: bash
      run: |
        set -e  # Exit on error
        
        echo "Current PATH: $PATH"
        echo "Looking for qmake..."
        which qmake || true
        
        # Check if qmake exists and is in PATH
        if ! command -v qmake &> /dev/null; then
          echo "‚ùå qmake not found in PATH"
          echo "Searching for qmake in Qt installation..."
          find "$HOME/Qt" -name qmake -type f 2>/dev/null || echo "No qmake found in Qt installation"
          exit 1
        fi
        
        # Verify Qt version (using sed for cross-platform compatibility)
        QT_VERSION_ACTUAL=$(qmake --version | sed -n 's/.*Using Qt version \([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
        if [[ -z "$QT_VERSION_ACTUAL" ]]; then
          echo "‚ùå Could not determine Qt version from qmake output:"
          qmake --version
          exit 1
        fi
        
        if [[ "$QT_VERSION_ACTUAL" != "${{ env.QT_VERSION }}"* ]]; then
          echo "‚ùå Wrong Qt version: $QT_VERSION_ACTUAL (expected ${{ env.QT_VERSION }})"
          exit 1
        fi
        
        echo "‚úÖ Qt $QT_VERSION_ACTUAL installed successfully"
        echo "qmake path: $(which qmake)"
        
    # Additional WASM tools
    - name: Install WASM tools
      if: matrix.qt_arch == 'wasm_32'
      run: |
        sudo apt-get update
        sudo apt-get install -y nodejs npm
        sudo npm install -g http-server
    
    - name: Make scripts executable
      run: |
        if [ "${{ runner.os }}" = "Windows" ]; then
          # On Windows, ensure execution policy allows script execution
          powershell -Command "Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process -Force"
        else
          # On Unix-like systems, make scripts executable
          chmod +x scripts/*.sh
        fi
    
    - name: Create build directories
      run: |
        # Create OS-specific build and package directories
        if [ "${{ runner.os }}" = "Windows" ]; then
          BUILD_DIR="build/windows"
          PACKAGE_DIR="packages/windows"
        elif [ "${{ runner.os }}" = "Linux" ]; then
          BUILD_DIR="build/linux"
          PACKAGE_DIR="packages/linux"
        else
          BUILD_DIR="build/macos"
          PACKAGE_DIR="packages/macos"
        fi
        
        # Create the directories
        mkdir -p "$BUILD_DIR"
        mkdir -p "$PACKAGE_DIR"
        
        # Set environment variables for subsequent steps
        echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
        echo "PACKAGE_DIR=$PACKAGE_DIR" >> $GITHUB_ENV
        
    - name: Build
      working-directory: ./qt_web_editor
      run: |
        if [ "${{ runner.os }}" = "Windows" ]; then
          # On Windows, use PowerShell with error handling
          $scriptName = [System.IO.Path]::GetFileName('${{ matrix.build_script }}')
          powershell -Command "& { $ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue'; & '..\scripts\$scriptName' }"
        else
          # On Unix-like systems, make script executable and run it
          chmod +x ../${{ matrix.build_script }}
          ../${{ matrix.build_script }}
        fi
    
    - name: Package
      working-directory: ./qt_web_editor
      run: |
        if [ "${{ runner.os }}" = "Windows" ]; then
          # On Windows, use PowerShell with error handling
          $scriptName = [System.IO.Path]::GetFileName('${{ matrix.package_script }}')
          powershell -Command "& { $ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue'; & '..\scripts\$scriptName' }"
        else
          # On Unix-like systems, make script executable and run it
          chmod +x ../${{ matrix.package_script }}
          ../${{ matrix.package_script }}
        fi
    
    - name: Package (Windows)
      if: matrix.package_script != '' && runner.os == 'Windows'
      working-directory: ./qt_web_editor
      run: powershell -File ..\${{ matrix.package_script }}
    
    # Upload build artifacts
    - name: Debug - List package directory
      run: |
        echo "Package directory contents:"
        find "${{ env.PACKAGE_DIR }}" -type f -o -type l 2>/dev/null || echo "No package directory found"
        echo "\nBuild directory contents:"
        find "${{ env.BUILD_DIR }}" -type f -o -type l 2>/dev/null || echo "No build directory found"

    - name: Upload Build Artifacts
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}-${{ github.run_id }}
        path: |
          ${{ env.PACKAGE_DIR }}/**/*
          ${{ env.BUILD_DIR }}/**/*.{wasm,js,html,dmg,app,exe,msi}
          ${{ env.BUILD_DIR }}/**/bin/*
        retention-days: 5
        if-no-files-found: warn
        compression-level: 9
    
    - name: Set success status
      if: success()
      run: echo "Build completed successfully for ${{ matrix.os }} (${{ matrix.qt_arch }})"
      shell: bash
    
  release:
    name: Create Release
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    # Only run if the build job was successful
    strategy:
      matrix:
        include:
          - os: macos-latest
            artifact_name: 'Rapid-macOS'
          - os: windows-latest
            artifact_name: 'Rapid-Windows'
          - os: ubuntu-latest
            artifact_name: 'Rapid-Web'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        pattern: '*-${{ github.run_id }}'
        merge-multiple: false
    
    - name: Prepare release assets
      run: |
        set -e  # Exit on error
        
        echo "üì¶ Preparing release assets..."
        
        # Create a release directory
        mkdir -p release
        
        # Check if we have any artifacts
        if [ ! "$(ls -A artifacts 2>/dev/null)" ]; then
          echo "‚ùå No artifacts found in artifacts/ directory"
          ls -la artifacts/ || true
          exit 1
        fi
        
        # Process each artifact
        for artifact in artifacts/*/; do
          if [ -d "$artifact" ]; then
            # Get the base name without the run ID
            base_name=$(basename "$artifact" | sed "s/-${{ github.run_id }}//")
            echo "üìÇ Processing artifact: $base_name"
            
            # Verify artifact is not empty
            if [ -z "$(ls -A "$artifact" 2>/dev/null)" ]; then
              echo "‚ö†Ô∏è  Warning: Empty artifact directory: $artifact"
              continue
            fi
            
            # Move and rename the artifact
            mv "$artifact" "release/$base_name" || {
              echo "‚ùå Failed to move artifact: $artifact"
              exit 1
            }
            
            # For WASM, ensure we have all necessary files
            if [[ "$base_name" == *"Web"* ]]; then
              echo "üåê Processing Web (WASM) files..."
              if ! cp -v release/"$base_name"/*.html release/ 2>/dev/null; then
                echo "‚ö†Ô∏è  No HTML files found in Web artifact"
              fi
            fi
          else
            echo "‚ö†Ô∏è  Skipping non-directory: $artifact"
          fi
        done
        
        # Verify we have at least one platform built
        if [ ! "$(ls -A release 2>/dev/null)" ]; then
          echo "‚ùå No valid artifacts found for release"
          exit 1
        fi
        
        echo "‚úÖ Release assets prepared successfully"
        echo "üìã Contents of release directory:"
        find release -type f | sort
    
    - name: Clean up build artifacts to save space
      run: |
        rm -rf build
        rm -rf packages
    
    - name: Create GitHub Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          release/**/*
        tag_name: ${{ github.ref_name }}
        name: Release ${{ github.ref_name }}
        body: |
          # Rapid ${{ github.ref_name }}
          
          ## Changes
          
          - [View Commits](https://github.com/${{ github.repository }}/compare/$(git describe --tags --abbrev=0 ${{ github.ref_name }}^)...${{ github.ref_name }})
          
          ## Downloads
          
          - **Windows**: [Rapid-Windows.msi](https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/Rapid-Windows.msi)
          - **macOS**: [Rapid-macOS.dmg](https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/Rapid-macOS.dmg)
          - **Web**: [Open in Browser](https://${{ github.repository_owner }}.github.io/rapid/)
        draft: false
        prerelease: false
        generate_release_notes: true
    
    - name: Deploy Web Version
      if: contains(github.ref, 'v')
      run: |
        if [ -d "release/Rapid-Web" ]; then
          cd release/Rapid-Web
          git init
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add .
          git commit -m "Deploy Web Version ${{ github.ref_name }}"
          git push -f https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git main:gh-pages
        fi
    
    # Release is created by the softprops/action-gh-release@v1 action above
